package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"fmt"
	"math/big"
	"time"

	"github.com/google/uuid"

	"github.com/davidalecrim/red-airlines/internal/graph/generated"
	"github.com/davidalecrim/red-airlines/internal/graph/model"
)

// Flight is the resolver for the flight field.
func (r *bookingResolver) Flight(ctx context.Context, obj *model.Booking) (*model.Flight, error) {
	result, err := r.Loaders.FlightLoader.Load(ctx, obj.FlightID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Fare is the resolver for the fare field.
func (r *bookingResolver) Fare(ctx context.Context, obj *model.Booking) (*model.Fare, error) {
	result, err := r.Loaders.FareLoader.Load(ctx, obj.FareID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Flight is the resolver for the flight field.
func (r *fareResolver) Flight(ctx context.Context, obj *model.Fare) (*model.Flight, error) {
	result, err := r.Loaders.FlightLoader.Load(ctx, obj.FlightID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Bookings is the resolver for the bookings field.
func (r *fareResolver) Bookings(ctx context.Context, obj *model.Fare) ([]*model.Booking, error) {
	result, err := r.Loaders.BookingsByFareLoader.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Fares is the resolver for the fares field.
func (r *flightResolver) Fares(ctx context.Context, obj *model.Flight) ([]*model.Fare, error) {
	result, err := r.Loaders.FaresByFlightLoader.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Bookings is the resolver for the bookings field.
func (r *flightResolver) Bookings(ctx context.Context, obj *model.Flight) ([]*model.Booking, error) {
	result, err := r.Loaders.BookingsByFlightLoader.Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CreateBooking is the resolver for the createBooking field.
func (r *mutationResolver) CreateBooking(ctx context.Context, input generated.CreateBookingInput) (*model.Booking, error) {
	tx, err := r.DB.BeginTxx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		_ = tx.Rollback()
	}()

	// Validate flight exists
	var flight model.Flight
	if err := tx.GetContext(ctx, &flight, "SELECT * FROM flights WHERE id = $1", input.FlightID); err != nil {
		return nil, fmt.Errorf("flight not found: %w", err)
	}

	// Validate fare exists and has available seats
	var fare model.Fare
	if err := tx.GetContext(ctx, &fare, "SELECT * FROM fares WHERE id = $1", input.FareID); err != nil {
		return nil, fmt.Errorf("fare not found: %w", err)
	}

	if fare.AvailableSeats <= 0 {
		return nil, fmt.Errorf("no available seats for this fare")
	}

	// Generate unique booking reference
	bookingReference := generateBookingReference()

	// Check uniqueness (very unlikely collision)
	var exists bool
	err = tx.GetContext(ctx, &exists, "SELECT EXISTS(SELECT 1 FROM bookings WHERE booking_reference = $1)", bookingReference)
	if err != nil {
		return nil, fmt.Errorf("failed to check booking reference uniqueness: %w", err)
	}
	if exists {
		bookingReference = generateBookingReference()
	}

	// Create booking
	booking := &model.Booking{
		ID:               generateUUID(),
		BookingReference: bookingReference,
		FlightID:         input.FlightID,
		FareID:           input.FareID,
		PassengerName:    input.PassengerName,
		PassengerEmail:   input.PassengerEmail,
		BookingStatus:    "confirmed",
		TotalPrice:       fare.Price,
		BookedAt:         time.Now(),
	}

	if input.PassengerPhone != nil {
		booking.PassengerPhone = *input.PassengerPhone
	}
	if input.SeatNumber != nil {
		booking.SeatNumber = *input.SeatNumber
	}

	query := `
		INSERT INTO bookings (id, booking_reference, flight_id, fare_id, passenger_name, passenger_email,
			passenger_phone, seat_number, booking_status, total_price, booked_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
	`
	_, err = tx.ExecContext(ctx, query,
		booking.ID, booking.BookingReference, booking.FlightID, booking.FareID,
		booking.PassengerName, booking.PassengerEmail, booking.PassengerPhone,
		booking.SeatNumber, booking.BookingStatus, booking.TotalPrice, booking.BookedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create booking: %w", err)
	}

	// Decrement available seats
	_, err = tx.ExecContext(ctx, "UPDATE fares SET available_seats = available_seats - 1 WHERE id = $1", input.FareID)
	if err != nil {
		return nil, fmt.Errorf("failed to update available seats: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return booking, nil
}

// Flights is the resolver for the flights field.
func (r *queryResolver) Flights(ctx context.Context, origin *string, destination *string, limit *int) ([]*model.Flight, error) {
	query := "SELECT * FROM flights WHERE 1=1"
	args := []any{}

	if origin != nil {
		query += " AND origin = ?"
		args = append(args, *origin)
	}
	if destination != nil {
		query += " AND destination = ?"
		args = append(args, *destination)
	}

	query += " ORDER BY departure_time"

	if limit != nil && *limit > 0 {
		query += " LIMIT ?"
		args = append(args, *limit)
	}

	query = r.DB.Rebind(query)

	var flights []*model.Flight
	if err := r.DB.SelectContext(ctx, &flights, query, args...); err != nil {
		return nil, err
	}

	return flights, nil
}

// Flight is the resolver for the flight field.
func (r *queryResolver) Flight(ctx context.Context, id string) (*model.Flight, error) {
	var flight model.Flight
	if err := r.DB.GetContext(ctx, &flight, "SELECT * FROM flights WHERE id = $1", id); err != nil {
		return nil, err
	}
	return &flight, nil
}

// Booking is the resolver for the booking field.
func (r *queryResolver) Booking(ctx context.Context, bookingReference string) (*model.Booking, error) {
	var booking model.Booking
	if err := r.DB.GetContext(ctx, &booking, "SELECT * FROM bookings WHERE booking_reference = $1", bookingReference); err != nil {
		return nil, err
	}
	return &booking, nil
}

// Bookings is the resolver for the bookings field.
func (r *queryResolver) Bookings(ctx context.Context, passengerEmail *string, limit *int) ([]*model.Booking, error) {
	query := "SELECT * FROM bookings WHERE 1=1"
	args := []any{}

	if passengerEmail != nil {
		query += " AND passenger_email = ?"
		args = append(args, *passengerEmail)
	}

	query += " ORDER BY booked_at DESC"

	if limit != nil && *limit > 0 {
		query += " LIMIT ?"
		args = append(args, *limit)
	}

	query = r.DB.Rebind(query)

	var bookings []*model.Booking
	if err := r.DB.SelectContext(ctx, &bookings, query, args...); err != nil {
		return nil, err
	}

	return bookings, nil
}

// Airports is the resolver for the airports field.
func (r *queryResolver) Airports(ctx context.Context) ([]string, error) {
	query := `
		SELECT DISTINCT airport
		FROM (
			SELECT origin AS airport FROM flights
			UNION
			SELECT destination AS airport FROM flights
		) AS all_airports
		ORDER BY airport
	`

	var airports []string
	if err := r.DB.SelectContext(ctx, &airports, query); err != nil {
		return nil, err
	}

	return airports, nil
}

// Booking returns generated.BookingResolver implementation.
func (r *Resolver) Booking() generated.BookingResolver { return &bookingResolver{r} }

// Fare returns generated.FareResolver implementation.
func (r *Resolver) Fare() generated.FareResolver { return &fareResolver{r} }

// Flight returns generated.FlightResolver implementation.
func (r *Resolver) Flight() generated.FlightResolver { return &flightResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type (
	bookingResolver  struct{ *Resolver }
	fareResolver     struct{ *Resolver }
	flightResolver   struct{ *Resolver }
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)

func generateUUID() string {
	return uuid.New().String()
}

func generateBookingReference() string {
	const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	const length = 7
	result := make([]byte, length)
	for i := range result {
		num, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
		result[i] = charset[num.Int64()]
	}
	return "RDA" + string(result)
}
